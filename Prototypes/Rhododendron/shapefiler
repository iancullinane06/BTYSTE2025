import os
import geopandas as gpd
import rasterio
import numpy as np
from skimage.io import imsave
from shapely.geometry import box
from dotenv import load_dotenv

load_dotenv()

data_dir = os.getenv('RHODODENDRON-DATASET-PRESPLIT')
out_dir = os.getenv('RHODODENDRON-DATASET-OUTPUT')

# Paths to my files and directories
raster_path = os.path.join(data_dir, 'Coillte_Multispectral.tif')
shapefile_path = os.path.join(data_dir, 'Rhodo_mapping.shp')
map_raster_path = os.path.join(data_dir, 'Rhodo_label.tif')
output_image_dir = os.path.join(out_dir, 'images')
output_map_dir = os.path.join(out_dir, 'maps')

grid_size = 244
crop_size = 122  # Half of the grid size
total_images = 0
rhododendron_images = 0
non_rhododendron_images = 0

# Create output directories if they don't exist
os.makedirs(output_image_dir, exist_ok=True)
os.makedirs(output_map_dir, exist_ok=True)
os.makedirs(os.path.join(output_image_dir, 'rhododendron'), exist_ok=True)
os.makedirs(os.path.join(output_image_dir, 'non_rhododendron'), exist_ok=True)
os.makedirs(os.path.join(output_map_dir, 'rhododendron'), exist_ok=True)
os.makedirs(os.path.join(output_map_dir, 'non_rhododendron'), exist_ok=True)

# Load the shapefile
gdf = gpd.read_file(shapefile_path)

# Load the map raster
with rasterio.open(map_raster_path) as map_src:
    map_data = map_src.read(1)  # Assuming single band raster

# Open the raster image for reading
with rasterio.open(raster_path) as src:
    transform = src.transform
    crs = src.crs

    # Check if the raster image is blank
    raster = src.read()
    if np.all((raster == 0) | (raster == 1)):
        print("The raster image contains only min and max values (0 and 1).")
        exit()

    # Define the bounding box of the raster
    raster_bounds = src.bounds
    raster_width = src.width
    raster_height = src.height

    # Convert shapefile to the raster CRS
    gdf = gdf.to_crs(crs)

    # Process the entire grid normally
    for i in range(0, raster_width, grid_size):
        for j in range(0, raster_height, grid_size):
            # Define the grid cell boundaries
            minx = raster_bounds.left + i * transform[0]
            maxx = minx + grid_size * transform[0]
            maxy = raster_bounds.top - j * abs(transform[4])
            miny = maxy - grid_size * abs(transform[4])

            cell_bounds = box(minx, miny, maxx, maxy)
            cell_center = cell_bounds.centroid

            # Extract the grid cell image
            window = rasterio.windows.Window(i, j, grid_size, grid_size)
            cell_image = src.read(window=window)

            # Check if the cell image contains only min and max values
            if np.all((cell_image == 0) | (cell_image == 1)):
                continue  # Skip cells with only min and max values

            # Normalize the cell image if it has a valid range
            cell_min = cell_image.min()
            cell_max = cell_image.max()
            if cell_min != cell_max:
                cell_image = (cell_image - cell_min) / (cell_max - cell_min) * 255
                cell_image = cell_image.astype(np.uint8)
            else:
                continue  # Skip images with no variation

            # Check for rhododendron presence
            intersects = gdf.intersects(cell_bounds).any()
            class_label = "rhododendron" if intersects else "non_rhododendron"
            output_subdir = os.path.join(output_image_dir, class_label)
            map_output_subdir = os.path.join(output_map_dir, class_label)
            file_name = f"{i}_{j}.tif"
            
            if intersects:
                rhododendron_images += 1
            else:
                non_rhododendron_images += 1

            # Save the image
            output_path = os.path.join(output_subdir, file_name)
            print(f"Saving image to: {output_path}")  # Debug print
            transposed_image = cell_image.transpose(1, 2, 0)
            imsave(output_path, transposed_image, plugin="tifffile", photometric='minisblack', planarconfig='contig')

            # Save the corresponding map
            map_output_path = os.path.join(map_output_subdir, file_name)
            print(f"Saving map to: {map_output_path}")  # Debug print
            map_cell = map_data[j:j+grid_size, i:i+grid_size]
            imsave(map_output_path, map_cell, plugin="tifffile", photometric='minisblack', planarconfig='contig')
            
            total_images += 1

    # Crop the entire image
    crop_window = rasterio.windows.Window(crop_size, crop_size, raster_width - 2*crop_size, raster_height - 2*crop_size)
    cropped_raster = src.read(window=crop_window)

    # Define new raster bounds after cropping
    cropped_minx = raster_bounds.left + crop_size * transform[0]
    cropped_maxx = cropped_minx + (raster_width - 2*crop_size) * transform[0]
    cropped_maxy = raster_bounds.top - crop_size * abs(transform[4])
    cropped_miny = cropped_maxy - (raster_height - 2*crop_size) * abs(transform[4])

    cropped_raster_bounds = (cropped_minx, cropped_miny, cropped_maxx, cropped_maxy)

    # Re-divide the cropped image into grid cells
    for i in range(0, raster_width - 2*crop_size, grid_size):
        for j in range(0, raster_height - 2*crop_size, grid_size):
            # Define the grid cell boundaries
            minx = cropped_raster_bounds[0] + i * transform[0]
            maxx = minx + grid_size * transform[0]
            maxy = cropped_raster_bounds[3] - j * abs(transform[4])
            miny = maxy - grid_size * abs(transform[4])

            cell_bounds = box(minx, miny, maxx, maxy)
            cell_center = cell_bounds.centroid

            # Extract the grid cell image from the cropped raster
            window = rasterio.windows.Window(crop_size + i, crop_size + j, grid_size, grid_size)
            cell_image = cropped_raster[:, j:j+grid_size, i:i+grid_size]

            # Check if the cell image contains only min and max values
            if np.all((cell_image == 0) | (cell_image == 1)):
                continue  # Skip cells with only min and max values

            # Normalize the cell image if it has a valid range
            cell_min = cell_image.min()
            cell_max = cell_image.max()
            if cell_min != cell_max:
                cell_image = (cell_image - cell_min) / (cell_max - cell_min) * 255
                cell_image = cell_image.astype(np.uint8)
            else:
                continue  # Skip images with no variation

            # Check for rhododendron presence
            intersects = gdf.intersects(cell_bounds).any()
            class_label = "rhododendron" if intersects else "non_rhododendron"
            output_subdir = os.path.join(output_image_dir, class_label)
            map_output_subdir = os.path.join(output_map_dir, class_label)
            file_name = f"cropped_{i}_{j}.tif"
            
            if intersects:
                rhododendron_images += 1
            else:
                non_rhododendron_images += 1

            # Save the image
            output_path = os.path.join(output_subdir, file_name)
            print(f"Saving cropped image to: {output_path}")  # Debug print
            transposed_image = cell_image.transpose(1, 2, 0)
            imsave(output_path, transposed_image, plugin="tifffile", photometric='minisblack', planarconfig='contig')

            # Save the corresponding map
            map_output_path = os.path.join(map_output_subdir, file_name)
            print(f"Saving cropped map to: {map_output_path}")  # Debug print
            map_cell = map_data[crop_size + j:crop_size + j + grid_size, crop_size + i:crop_size + i + grid_size]
            imsave(map_output_path, map_cell, plugin="tifffile", photometric='minisblack', planarconfig='contig')
            
            total_images += 1

print("Processing complete.")
print(f"Total images: {total_images}")
print(f"Rhododendron images: {rhododendron_images}")
print(f"Non-rhododendron images: {non_rhododendron_images}")
