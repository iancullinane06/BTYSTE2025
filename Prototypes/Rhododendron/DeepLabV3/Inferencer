import os
import numpy as np
import tensorflow as tf
from keras.models import load_model
import tifffile as tiff
import matplotlib.pyplot as plt
import random
import tensorflow as tf
from dotenv import load_dotenv
from keras import backend as K

# Load environment variables
load_dotenv()

# Define parameters
IMG_HEIGHT = 244
IMG_WIDTH = 244
IMG_CHANNELS = 6
MODEL_PATH = os.getenv('RHODODENDRON-DEEPLAB-MODEL')  # Path to the saved model
IMAGE_DIR = os.getenv('RHODODENDRON-SAMPLES')  # Directory containing all images
MASK_DIR = os.getenv('RHODODENDRON-SAMPLES-MASKS')  # Directory containing all masks
MODEL_PATH = os.getenv('RHODODENDRON-DEEPLAB-MODEL')

# Define Boundary IoU
def boundary_iou(y_true, y_pred, threshold=0.5):
    def binary_boundary(mask):
        mask = tf.cast(mask > threshold, tf.uint8)
        boundary = tf.image.sobel_edges(tf.cast(mask, tf.float32))
        return tf.reduce_sum(tf.abs(boundary), axis=-1)

    y_true_boundary = binary_boundary(y_true)
    y_pred_boundary = binary_boundary(y_pred)

    intersect = tf.reduce_sum(tf.minimum(y_true_boundary, y_pred_boundary))
    union = tf.reduce_sum(tf.maximum(y_true_boundary, y_pred_boundary))

    iou = (intersect + 1e-6) / (union + 1e-6)
    return tf.reduce_mean(iou)

# Define Background Accuracy
def background_accuracy(y_true, y_pred, threshold=0.5):
    y_true_bin = tf.cast(y_true > threshold, tf.float32)
    y_pred_bin = tf.cast(y_pred > threshold, tf.float32)
    background_mask = tf.cast(y_true_bin == 0, tf.float32)
    
    correct_background_preds = tf.reduce_sum(background_mask * y_pred_bin)
    total_background_pixels = tf.reduce_sum(background_mask)
    
    background_accuracy = (correct_background_preds + 1e-6) / (total_background_pixels + 1e-6)
    return tf.reduce_mean(background_accuracy)

# Define Composite Loss Function
def composite_loss(alpha=1.0, beta=1.0, threshold=0.5):
    def loss(y_true, y_pred):
        boundary_iou_value = boundary_iou(y_true, y_pred, threshold)
        background_accuracy_value = background_accuracy(y_true, y_pred, threshold)
        bce_loss = tf.keras.losses.binary_crossentropy(y_true, y_pred)
        combined_loss = alpha * boundary_iou_value - beta * background_accuracy_value + bce_loss
        return combined_loss
    return loss

def mean_iou(y_true, y_pred, num_classes=2):
    y_true = tf.cast(y_true, tf.int32)
    y_pred = tf.argmax(y_pred, axis=-1)
    y_pred = tf.cast(y_pred, tf.int32)

    # Calculate IoU for each class
    iou = []
    for i in range(num_classes):
        true_mask = tf.equal(y_true, i)
        pred_mask = tf.equal(y_pred, i)
        intersection = tf.reduce_sum(tf.cast(true_mask & pred_mask, tf.float32))
        union = tf.reduce_sum(tf.cast(true_mask | pred_mask, tf.float32))
        iou.append(intersection / (union + tf.keras.backend.epsilon()))

    # Return mean IoU
    return tf.reduce_mean(iou)

def boundary_iou(y_true, y_pred, threshold=0.5):
    def binary_boundary(mask):
        """Extracts boundary from a binary mask."""
        mask = tf.cast(mask > threshold, tf.uint8)
        boundary = tf.image.sobel_edges(tf.cast(mask, tf.float32))
        return tf.reduce_sum(tf.abs(boundary), axis=-1)

    y_true_boundary = binary_boundary(y_true)
    y_pred_boundary = binary_boundary(y_pred)

    intersect = tf.reduce_sum(tf.minimum(y_true_boundary, y_pred_boundary))
    union = tf.reduce_sum(tf.maximum(y_true_boundary, y_pred_boundary))

    iou = (intersect + 1e-6) / (union + 1e-6)  # Avoid division by zero
    return tf.reduce_mean(iou)

model = load_model(MODEL_PATH, custom_objects={'boundary_iou': boundary_iou})

def preprocess_image(image_path, img_height, img_width):
    """
    Preprocesses the image for inference.
    """
    img = tiff.imread(image_path)
    
    # Ensure the image has the right number of channels
    if img.ndim == 2:  # If grayscale
        img = np.stack([img] * IMG_CHANNELS, axis=-1)  # Convert to 6-channel image
    
    img = tf.image.resize(img, (img_height, img_width))
    img = img / 255.0  # Normalize
    return np.expand_dims(img, axis=0)  # Add batch dimension

def run_inference(model, image_path):
    """
    Runs inference on a single image.
    """
    img = preprocess_image(image_path, IMG_HEIGHT, IMG_WIDTH)
    prediction = model.predict(img)
    return prediction[0]

def visualize_results(original_image_path, mask_path, prediction):
    """
    Visualizes the original image channels, the mask, and the predicted mask.
    """
    img = tiff.imread(original_image_path)
    mask = tiff.imread(mask_path)
    
    # Handle multi-channel images
    if img.ndim == 2:  # If grayscale
        img = np.stack([img] * IMG_CHANNELS, axis=-1)  # Convert to 6-channel image
    
    # Ensure mask has a channel dimension
    if mask.ndim == 2:
        mask = np.expand_dims(mask, axis=-1)  # Convert to (H, W, 1)
    
    # Resize image and mask
    img_resized = tf.image.resize(img, (IMG_HEIGHT, IMG_WIDTH)).numpy()
    mask_resized = tf.image.resize(mask, (IMG_HEIGHT, IMG_WIDTH)).numpy()
    
    num_channels = IMG_CHANNELS
    num_cols = 3
    num_rows = (num_channels + 1 + num_cols - 1) // num_cols  # Add 1 for the mask and 1 for the predicted mask
    
    plt.figure(figsize=(20, 5 * num_rows))  # Adjust the figsize as needed
    
    # Display each channel of the original image
    for i in range(num_channels):
        plt.subplot(num_rows, num_cols, i + 1)
        plt.imshow(img_resized[:, :, i], cmap='gray')
        plt.title(f'Original Channel {i+1}')
        plt.axis('off')
    
    # Display the original mask
    plt.subplot(num_rows, num_cols, num_channels + 1)
    plt.imshow(mask_resized[:, :, 0], cmap='gray')
    plt.title('Original Mask')
    plt.axis('off')
    
    # Display the predicted mask
    plt.subplot(num_rows, num_cols, num_channels + 2)
    plt.imshow(prediction.squeeze(), cmap='gray')
    plt.title('Predicted Mask')
    plt.axis('off')
    
    plt.show()

# Select a random image from the directory
if IMAGE_DIR and MASK_DIR:
    image_files = [f for f in os.listdir(IMAGE_DIR) if f.endswith('.tif')]
    if not image_files:
        print("No TIFF images found in the specified directory.")
    else:
        random_image = random.choice(image_files)
        image_path = os.path.join(IMAGE_DIR, random_image)
        mask_path = os.path.join(MASK_DIR, random_image)  # Assuming masks have the same name
        
        prediction = run_inference(model, image_path)
        visualize_results(image_path, mask_path, prediction)
else:
    print("Environment variables 'RHODODENDRON-SAMPLES' or 'RHODODENDRON-SAMPLES-MASKS' not set.")
